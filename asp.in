#!/bin/bash

ARCH_GIT_REPOS=(packages community)

OPT_ARCH=$(uname -m)
OPT_FORCE=0
: ${ASPROOT:=$HOME/asp}
: ${ASPCACHE:=${XDG_CACHE_HOME:-$HOME/.cache}/asp}

m4_include(util.inc.sh)
m4_include(remote.inc.sh)
m4_include(package.inc.sh)

usage() {
  cat<<EOF
asp [OPTIONS...] {COMMAND} ...

Manage build sources for Arch packages.

Options:
  -a           ARCH        Specify an architecture other than the host's
  -f                       Allow files to be overwritten
  -h                       Show this help
  -V                       Show package version

Commands:
  checkout     NAME...     Create a mutable git repository for packages
  difflog      NAME        Show revision history with diffs
  export       NAME...     Export packages
  gc                       Cleanup and optimize the local repository
  disk-usage               Show amount of disk used by locally tracked packages
  help                     Show this help
  list-all                 List all known packages
  list-arches  NAME...     List architectures for packages
  list-local               List tracked packages
  list-repos   NAME...     List repos for packages
  log          NAME        Show revision history
  show         NAME        Show the PKGBUILD
  shortlog     NAME        Show revision history in short form
  update       [NAME...]   Update packages (update all tracked if none specified)
  untrack      NAME...     Remove a package from the local repository
EOF
}

__require_argc() {
  local operator=$1 expected=$2 got=$(( ${#BASH_ARGV[@]} - 1 ))

  case $operator in
    '==')
      (( got == expected )) ||
          log_fatal '%s expects %d args, got %d' "${FUNCNAME[1]#action__}" "$expected" "$got"
      ;;
    '>=')
      (( got >= expected )) ||
          log_fatal '%s expects at least %d args, got %d' "${FUNCNAME[1]#action__}" "$expected" "$got"
      ;;
    '<=')
      (( got <= expected )) ||
          log_fatal '%s expects at most %d args, got %d' "${FUNCNAME[1]#action__}" "$expected" "$got"
      ;;
  esac
}

version() {
  printf 'asp v0\n'
}

update_all() {
  local r

  for r in "${ARCH_GIT_REPOS[@]}"; do
    log_info "updating remote '%s'" "$r"
    remote_update "$r"
  done
}

update_local_branches() {
  local r=0

  while read -r branchname; do
    git branch -qf "$branchname" "refs/remotes/$branchname" || r=1
  done < <(git branch)

  return "$r"
}

update_remote_branches() {
  local refspecs=() remote pkgname
  declare -A refspec_map

  if (( $# == 0 )); then
    update_all
    return
  fi

  # map packages to remotes
  for pkgname; do
    package_init -n "$pkgname" remote || return 1
    refspec_map["$remote"]+=" packages/$pkgname"
  done

  # update each remote all at once
  for remote in "${!refspec_map[@]}"; do
    read -ra refspecs <<<"${refspec_map["$remote"]}"
    remote_update_refs "$remote" "${refspecs[@]}"
  done
}

update_packages() {
  update_remote_branches "$@" && update_local_branches
}

initialize() {
  local remote

  [[ -d $ASPCACHE ]] || mkdir -p "$ASPCACHE"

  [[ -f .asp ]] && return 0

  git init || return 1

  for remote in "${ARCH_GIT_REPOS[@]}"; do
    git remote add "$remote" git://git.archlinux.org/svntogit/"$remote".git
  done

  touch .asp
}

dump_packages() {
  local remote refspecs dumpfn

  case $1 in
    all)
      dumpfn=remote_get_all_refs
      ;;
    local)
      dumpfn=remote_get_tracked_refs
      ;;
    *)
      die 'internal error: invalid dump type: "%s"' "$1"
      ;;
  esac

  for remote in "${ARCH_GIT_REPOS[@]}"; do
    "$dumpfn" "$remote" refspecs
    if [[ $refspecs ]]; then
      printf '%s\n' "${refspecs[@]/#packages/"$remote"}"
    fi
  done
}

list_local() {
  dump_packages 'local'
}

list_all() {
  dump_packages 'all'
}

shortlog() {
  package_log "$@" "${FUNCNAME[0]}"
}

log() {
  package_log "$@" "${FUNCNAME[0]}"
}

difflog() {
  package_log "$@" "${FUNCNAME[0]}"
}

gc() {
  git prune
  git gc
}

untrack() {
  local pkgname=$1 remote

  package_init -n "$pkgname" remote || return 1

  remote_untrack "$remote" "$pkgname"
  package_untrack "$pkgname" "$remote"
}

disk_usage() {
  local usage
  read usage _ < <(du -sh "$ASPROOT")

  log_info 'Using %s on disk.' "$usage"
}

action__checkout() {
  __require_argc '>=' 1
  map package_checkout "$@"
}

action__difflog() {
  __require_argc == 1
  difflog "$1"
}

action__disk-usage() {
  __require_argc == 0
  disk_usage
}

action__export() {
  __require_argc '>=' 1
  map package_export "$@"
}

action__gc() {
  __require_argc == 0
  gc
}

action__help() {
  __require_argc == 0
  usage
}

action__list-all() {
  __require_argc == 0
  list_all
}

action__list-arches() {
  __require_argc '>=' 1
  map package_get_arches "$@"
}

action__list-local() {
  __require_argc == 0
  list_local
}

action__list-repos() {
  __require_argc '>=' 1
  map package_get_repos "$@"
}

action__log() {
  __require_argc == 1
  log "$1"
}

action__shortlog() {
  __require_argc == 1
  shortlog "$1"
}

action__show() {
  __require_argc == 1
  package_show_pkgbuild "$1"
}

action__untrack() {
  __require_argc '>=' 1
  map untrack "$@"
}

action__update() {
  update_packages "$@"
}

dispatch_action() {
  local a candidates=()
  local actions=(
    checkout
    difflog
    disk-usage
    export
    gc
    help
    list-all
    list-arches
    list-local
    list-repos
    log
    shortlog
    show
    untrack
    update
  )

  [[ $1 ]] || log_fatal 'no action specified (use -h for help)'

  for a in "${actions[@]}"; do
    if [[ $a = "$1" ]]; then
      candidates=("$a")
      break
    fi

    [[ $a = "$1"* ]] && candidates+=("$a")
  done

  case ${#candidates[*]} in
    0)
      log_fatal 'unknown action: %s' "$1"
      ;;
    1)
      "action__${candidates[0]}" "${@:2}"
      ;;
    *)
      {
        printf "error: verb '%s' is ambiguous; possibilities:" "$1"
        printf " '%s'" "${candidates[@]}"
        echo
      } >&2
  esac
}

umask 0022
startdir=$PWD
cd "$ASPROOT" || log_fatal "ASPROOT ($ASPROOT) does not exist!"
initialize

while getopts ':a:fhV' flag; do
  case $flag in
    a)
      OPT_ARCH=$OPTARG
      ;;
    f)
      OPT_FORCE=1
      ;;
    h)
      usage
      exit 0
      ;;
    V)
      version
      exit 0
      ;;
    \?)
      log_fatal "invalid option -- '%s'" "$OPTARG"
      ;;
    :)
      log_fatal "option '-%s' requires an argument" "$OPTARG"
      ;;
  esac
done
shift $(( OPTIND - 1 ))

dispatch_action "$@"

